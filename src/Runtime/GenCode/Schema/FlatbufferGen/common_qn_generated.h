// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMONQN_ARKQNDATA_H_
#define FLATBUFFERS_GENERATED_COMMONQN_ARKQNDATA_H_

#include "flatbuffers/flatbuffers.h"

namespace ArkQnData {

struct float2;

struct int3;

struct float3;

struct double3;

struct float4;

struct ubyte4;

struct byte4;

struct int4;

struct TinyWeight;

struct TinyVector;

struct TinyTangent;

struct TinyQuaternion;

struct Matrix;

struct RichCurveKey;
struct RichCurveKeyT;

struct RichCurve;
struct RichCurveT;

struct RichCurveVector;
struct RichCurveVectorT;

struct ShaderParamVal;
struct ShaderParamValT;

struct ShaderRenderParam;
struct ShaderRenderParamT;

struct MapFloatColor;

struct MapFloatUbyte;

struct MapFloatByte;

struct MapFloatUint;

struct MapFloatInt;

struct MapFloatFloat;

struct MapFloatFloat3;

struct MapIntInt;

struct TextureRenderParam;
struct TextureRenderParamT;

struct PieceRenderParam;
struct PieceRenderParamT;

struct ArpRenderParam;
struct ArpRenderParamT;

struct PrefabRenderParam;
struct PrefabRenderParamT;

struct OptUbyte;

enum EResType {
  EResType_Meta = 0,
  EResType_MRT_Arp = 1,
  EResType_MRT_Ani = 2,
  EResType_MRT_Ara = 3,
  EResType_MRT_Anf = 4,
  EResType_MRT_Act = 5,
  EResType_MRT_Child = 6,
  EResType_MRT_Hkp = 7,
  EResType_MRT_Tex = 8,
  EResType_MRT_Font = 9,
  EResType_MRT_Are = 10,
  EResType_MRT_Phys = 11,
  EResType_MRT_Blast = 12,
  EResType_MRT_Effect = 13,
  EResType_Mtl = 14,
  EResType_MRT_Raw = 15,
  EResType_MRT_Cloth = 16,
  EResType_MRT_Prefab = 17,
  EResType_MRT_GUIAnimator = 18,
  EResType_MRT_GUIAnimationClip = 19,
  EResType_MRT_Spt = 20,
  EResType_MRT_SoundMask = 21,
  EResType_MRT_Preload = 22,
  EResType_MRT_Event = 23,
  EResType_MRT_Face = 24,
  EResType_MRT_Hair = 25,
  EResType_MRT_Audio = 26,
  EResType_MRT_FxDebris = 27,
  EResType_MRT_MtlInst = 28,
  EResType_MRT_OBJ = 29,
  EResType_MRT_Dyeing = 30,
  EResType_MRT_Appearance = 31,
  EResType_MRT_Bitmap = 32,
  EResType_MRT_LogicComponent = 33,
  EResType_MIN = EResType_Meta,
  EResType_MAX = EResType_MRT_LogicComponent
};

inline const EResType (&EnumValuesEResType())[34] {
  static const EResType values[] = {
    EResType_Meta,
    EResType_MRT_Arp,
    EResType_MRT_Ani,
    EResType_MRT_Ara,
    EResType_MRT_Anf,
    EResType_MRT_Act,
    EResType_MRT_Child,
    EResType_MRT_Hkp,
    EResType_MRT_Tex,
    EResType_MRT_Font,
    EResType_MRT_Are,
    EResType_MRT_Phys,
    EResType_MRT_Blast,
    EResType_MRT_Effect,
    EResType_Mtl,
    EResType_MRT_Raw,
    EResType_MRT_Cloth,
    EResType_MRT_Prefab,
    EResType_MRT_GUIAnimator,
    EResType_MRT_GUIAnimationClip,
    EResType_MRT_Spt,
    EResType_MRT_SoundMask,
    EResType_MRT_Preload,
    EResType_MRT_Event,
    EResType_MRT_Face,
    EResType_MRT_Hair,
    EResType_MRT_Audio,
    EResType_MRT_FxDebris,
    EResType_MRT_MtlInst,
    EResType_MRT_OBJ,
    EResType_MRT_Dyeing,
    EResType_MRT_Appearance,
    EResType_MRT_Bitmap,
    EResType_MRT_LogicComponent
  };
  return values;
}

inline const char * const *EnumNamesEResType() {
  static const char * const names[] = {
    "Meta",
    "MRT_Arp",
    "MRT_Ani",
    "MRT_Ara",
    "MRT_Anf",
    "MRT_Act",
    "MRT_Child",
    "MRT_Hkp",
    "MRT_Tex",
    "MRT_Font",
    "MRT_Are",
    "MRT_Phys",
    "MRT_Blast",
    "MRT_Effect",
    "Mtl",
    "MRT_Raw",
    "MRT_Cloth",
    "MRT_Prefab",
    "MRT_GUIAnimator",
    "MRT_GUIAnimationClip",
    "MRT_Spt",
    "MRT_SoundMask",
    "MRT_Preload",
    "MRT_Event",
    "MRT_Face",
    "MRT_Hair",
    "MRT_Audio",
    "MRT_FxDebris",
    "MRT_MtlInst",
    "MRT_OBJ",
    "MRT_Dyeing",
    "MRT_Appearance",
    "MRT_Bitmap",
    "MRT_LogicComponent",
    nullptr
  };
  return names;
}

inline const char *EnumNameEResType(EResType e) {
  if (e < EResType_Meta || e > EResType_MRT_LogicComponent) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEResType()[index];
}

enum EBlendType {
  EBlendType_BT_OFF = 0,
  EBlendType_BT_ONE_ONE = 1,
  EBlendType_BT_INVCD_CD = 2,
  EBlendType_BT_AS_INVAS = 3,
  EBlendType_BT_CS_INVCS = 4,
  EBlendType_BT_CD_INVCD = 5,
  EBlendType_BT_CS_ONE = 6,
  EBlendType_BT_AS_ZERO = 7,
  EBlendType_BT_AS_ONE = 8,
  EBlendType_BT_CD_ZERO = 9,
  EBlendType_BT_ONE_INVAS = 10,
  EBlendType_BT_CS_INVAS = 11,
  EBlendType_BT_AD_REV_SUBTRACT_ONE = 12,
  EBlendType_BT_CD_INVAS = 13,
  EBlendType_BT_ONE_INVCS = 14,
  EBlendType_BT_ZERO_ONE = 15,
  EBlendType_MIN = EBlendType_BT_OFF,
  EBlendType_MAX = EBlendType_BT_ZERO_ONE
};

inline const EBlendType (&EnumValuesEBlendType())[16] {
  static const EBlendType values[] = {
    EBlendType_BT_OFF,
    EBlendType_BT_ONE_ONE,
    EBlendType_BT_INVCD_CD,
    EBlendType_BT_AS_INVAS,
    EBlendType_BT_CS_INVCS,
    EBlendType_BT_CD_INVCD,
    EBlendType_BT_CS_ONE,
    EBlendType_BT_AS_ZERO,
    EBlendType_BT_AS_ONE,
    EBlendType_BT_CD_ZERO,
    EBlendType_BT_ONE_INVAS,
    EBlendType_BT_CS_INVAS,
    EBlendType_BT_AD_REV_SUBTRACT_ONE,
    EBlendType_BT_CD_INVAS,
    EBlendType_BT_ONE_INVCS,
    EBlendType_BT_ZERO_ONE
  };
  return values;
}

inline const char * const *EnumNamesEBlendType() {
  static const char * const names[] = {
    "BT_OFF",
    "BT_ONE_ONE",
    "BT_INVCD_CD",
    "BT_AS_INVAS",
    "BT_CS_INVCS",
    "BT_CD_INVCD",
    "BT_CS_ONE",
    "BT_AS_ZERO",
    "BT_AS_ONE",
    "BT_CD_ZERO",
    "BT_ONE_INVAS",
    "BT_CS_INVAS",
    "BT_AD_REV_SUBTRACT_ONE",
    "BT_CD_INVAS",
    "BT_ONE_INVCS",
    "BT_ZERO_ONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEBlendType(EBlendType e) {
  if (e < EBlendType_BT_OFF || e > EBlendType_BT_ZERO_ONE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEBlendType()[index];
}

enum EComparisonFunc {
  EComparisonFunc_CF_NEVER = 0,
  EComparisonFunc_CF_LESS = 1,
  EComparisonFunc_CF_EQUAL = 2,
  EComparisonFunc_CF_LESS_EQUAL = 3,
  EComparisonFunc_CF_GREATER = 4,
  EComparisonFunc_CF_NOT_EQUAL = 5,
  EComparisonFunc_CF_GREATER_EQUAL = 6,
  EComparisonFunc_CF_ALWAYS = 7,
  EComparisonFunc_MIN = EComparisonFunc_CF_NEVER,
  EComparisonFunc_MAX = EComparisonFunc_CF_ALWAYS
};

inline const EComparisonFunc (&EnumValuesEComparisonFunc())[8] {
  static const EComparisonFunc values[] = {
    EComparisonFunc_CF_NEVER,
    EComparisonFunc_CF_LESS,
    EComparisonFunc_CF_EQUAL,
    EComparisonFunc_CF_LESS_EQUAL,
    EComparisonFunc_CF_GREATER,
    EComparisonFunc_CF_NOT_EQUAL,
    EComparisonFunc_CF_GREATER_EQUAL,
    EComparisonFunc_CF_ALWAYS
  };
  return values;
}

inline const char * const *EnumNamesEComparisonFunc() {
  static const char * const names[] = {
    "CF_NEVER",
    "CF_LESS",
    "CF_EQUAL",
    "CF_LESS_EQUAL",
    "CF_GREATER",
    "CF_NOT_EQUAL",
    "CF_GREATER_EQUAL",
    "CF_ALWAYS",
    nullptr
  };
  return names;
}

inline const char *EnumNameEComparisonFunc(EComparisonFunc e) {
  if (e < EComparisonFunc_CF_NEVER || e > EComparisonFunc_CF_ALWAYS) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEComparisonFunc()[index];
}

enum ECullMode {
  ECullMode_CMD_NONE = 0,
  ECullMode_CMD_CW = 1,
  ECullMode_CMD_CCW = 2,
  ECullMode_MIN = ECullMode_CMD_NONE,
  ECullMode_MAX = ECullMode_CMD_CCW
};

inline const ECullMode (&EnumValuesECullMode())[3] {
  static const ECullMode values[] = {
    ECullMode_CMD_NONE,
    ECullMode_CMD_CW,
    ECullMode_CMD_CCW
  };
  return values;
}

inline const char * const *EnumNamesECullMode() {
  static const char * const names[] = {
    "CMD_NONE",
    "CMD_CW",
    "CMD_CCW",
    nullptr
  };
  return names;
}

inline const char *EnumNameECullMode(ECullMode e) {
  if (e < ECullMode_CMD_NONE || e > ECullMode_CMD_CCW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesECullMode()[index];
}

enum EFillMode {
  EFillMode_FM_POINT = 0,
  EFillMode_FM_WIREFRAME = 1,
  EFillMode_FM_SOLID = 2,
  EFillMode_MIN = EFillMode_FM_POINT,
  EFillMode_MAX = EFillMode_FM_SOLID
};

inline const EFillMode (&EnumValuesEFillMode())[3] {
  static const EFillMode values[] = {
    EFillMode_FM_POINT,
    EFillMode_FM_WIREFRAME,
    EFillMode_FM_SOLID
  };
  return values;
}

inline const char * const *EnumNamesEFillMode() {
  static const char * const names[] = {
    "FM_POINT",
    "FM_WIREFRAME",
    "FM_SOLID",
    nullptr
  };
  return names;
}

inline const char *EnumNameEFillMode(EFillMode e) {
  if (e < EFillMode_FM_POINT || e > EFillMode_FM_SOLID) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEFillMode()[index];
}

enum ETextureFilterType {
  ETextureFilterType_FT_NONE = 0,
  ETextureFilterType_FT_POINT = 1,
  ETextureFilterType_FT_LINEAR = 2,
  ETextureFilterType_FT_ANISOTROPIC = 3,
  ETextureFilterType_FT_CMP_POINT = 17,
  ETextureFilterType_FT_CMP_LINEAR = 18,
  ETextureFilterType_FT_CMP_ANISOTROPIC = 19,
  ETextureFilterType_FT_COUNT = 20,
  ETextureFilterType_MIN = ETextureFilterType_FT_NONE,
  ETextureFilterType_MAX = ETextureFilterType_FT_COUNT
};

inline const ETextureFilterType (&EnumValuesETextureFilterType())[8] {
  static const ETextureFilterType values[] = {
    ETextureFilterType_FT_NONE,
    ETextureFilterType_FT_POINT,
    ETextureFilterType_FT_LINEAR,
    ETextureFilterType_FT_ANISOTROPIC,
    ETextureFilterType_FT_CMP_POINT,
    ETextureFilterType_FT_CMP_LINEAR,
    ETextureFilterType_FT_CMP_ANISOTROPIC,
    ETextureFilterType_FT_COUNT
  };
  return values;
}

inline const char * const *EnumNamesETextureFilterType() {
  static const char * const names[] = {
    "FT_NONE",
    "FT_POINT",
    "FT_LINEAR",
    "FT_ANISOTROPIC",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "FT_CMP_POINT",
    "FT_CMP_LINEAR",
    "FT_CMP_ANISOTROPIC",
    "FT_COUNT",
    nullptr
  };
  return names;
}

inline const char *EnumNameETextureFilterType(ETextureFilterType e) {
  if (e < ETextureFilterType_FT_NONE || e > ETextureFilterType_FT_COUNT) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesETextureFilterType()[index];
}

enum ETextureAddress {
  ETextureAddress_TA_WRAP = 0,
  ETextureAddress_TA_MIRROR = 1,
  ETextureAddress_TA_CLAMP = 2,
  ETextureAddress_TA_BORDER = 3,
  ETextureAddress_TA_MIRRORONCE = 4,
  ETextureAddress_MIN = ETextureAddress_TA_WRAP,
  ETextureAddress_MAX = ETextureAddress_TA_MIRRORONCE
};

inline const ETextureAddress (&EnumValuesETextureAddress())[5] {
  static const ETextureAddress values[] = {
    ETextureAddress_TA_WRAP,
    ETextureAddress_TA_MIRROR,
    ETextureAddress_TA_CLAMP,
    ETextureAddress_TA_BORDER,
    ETextureAddress_TA_MIRRORONCE
  };
  return values;
}

inline const char * const *EnumNamesETextureAddress() {
  static const char * const names[] = {
    "TA_WRAP",
    "TA_MIRROR",
    "TA_CLAMP",
    "TA_BORDER",
    "TA_MIRRORONCE",
    nullptr
  };
  return names;
}

inline const char *EnumNameETextureAddress(ETextureAddress e) {
  if (e < ETextureAddress_TA_WRAP || e > ETextureAddress_TA_MIRRORONCE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesETextureAddress()[index];
}

enum EShaderTexType {
  EShaderTexType_STT_DIFFUSE = 0,
  EShaderTexType_STT_SPECULAR = 1,
  EShaderTexType_STT_BUMP = 2,
  EShaderTexType_STT_EFFECT_0 = 3,
  EShaderTexType_STT_EFFECT_1 = 4,
  EShaderTexType_STT_EFFECT_2 = 5,
  EShaderTexType_STT_EFFECT_3 = 6,
  EShaderTexType_STT_EFFECT_4 = 7,
  EShaderTexType_STT_INFOMATION = 8,
  EShaderTexType_STT_MAX = 9,
  EShaderTexType_MIN = EShaderTexType_STT_DIFFUSE,
  EShaderTexType_MAX = EShaderTexType_STT_MAX
};

inline const EShaderTexType (&EnumValuesEShaderTexType())[10] {
  static const EShaderTexType values[] = {
    EShaderTexType_STT_DIFFUSE,
    EShaderTexType_STT_SPECULAR,
    EShaderTexType_STT_BUMP,
    EShaderTexType_STT_EFFECT_0,
    EShaderTexType_STT_EFFECT_1,
    EShaderTexType_STT_EFFECT_2,
    EShaderTexType_STT_EFFECT_3,
    EShaderTexType_STT_EFFECT_4,
    EShaderTexType_STT_INFOMATION,
    EShaderTexType_STT_MAX
  };
  return values;
}

inline const char * const *EnumNamesEShaderTexType() {
  static const char * const names[] = {
    "STT_DIFFUSE",
    "STT_SPECULAR",
    "STT_BUMP",
    "STT_EFFECT_0",
    "STT_EFFECT_1",
    "STT_EFFECT_2",
    "STT_EFFECT_3",
    "STT_EFFECT_4",
    "STT_INFOMATION",
    "STT_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameEShaderTexType(EShaderTexType e) {
  if (e < EShaderTexType_STT_DIFFUSE || e > EShaderTexType_STT_MAX) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEShaderTexType()[index];
}

enum EShaderParamType {
  EShaderParamType_Type_UNKNOWN = 0,
  EShaderParamType_Type_BOOL = 1,
  EShaderParamType_Type_INT = 2,
  EShaderParamType_Type_UINT = 3,
  EShaderParamType_Type_HALF = 4,
  EShaderParamType_Type_FLOAT = 5,
  EShaderParamType_Type_FCOLOR = 6,
  EShaderParamType_Type_VECTOR2 = 7,
  EShaderParamType_Type_VECTOR3 = 8,
  EShaderParamType_Type_VECTOR4 = 9,
  EShaderParamType_Type_TEX = 10,
  EShaderParamType_Type_VECTOR4_ARRAY = 11,
  EShaderParamType_Type_FCOLOR_GRADIENT = 12,
  EShaderParamType_MIN = EShaderParamType_Type_UNKNOWN,
  EShaderParamType_MAX = EShaderParamType_Type_FCOLOR_GRADIENT
};

inline const EShaderParamType (&EnumValuesEShaderParamType())[13] {
  static const EShaderParamType values[] = {
    EShaderParamType_Type_UNKNOWN,
    EShaderParamType_Type_BOOL,
    EShaderParamType_Type_INT,
    EShaderParamType_Type_UINT,
    EShaderParamType_Type_HALF,
    EShaderParamType_Type_FLOAT,
    EShaderParamType_Type_FCOLOR,
    EShaderParamType_Type_VECTOR2,
    EShaderParamType_Type_VECTOR3,
    EShaderParamType_Type_VECTOR4,
    EShaderParamType_Type_TEX,
    EShaderParamType_Type_VECTOR4_ARRAY,
    EShaderParamType_Type_FCOLOR_GRADIENT
  };
  return values;
}

inline const char * const *EnumNamesEShaderParamType() {
  static const char * const names[] = {
    "Type_UNKNOWN",
    "Type_BOOL",
    "Type_INT",
    "Type_UINT",
    "Type_HALF",
    "Type_FLOAT",
    "Type_FCOLOR",
    "Type_VECTOR2",
    "Type_VECTOR3",
    "Type_VECTOR4",
    "Type_TEX",
    "Type_VECTOR4_ARRAY",
    "Type_FCOLOR_GRADIENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameEShaderParamType(EShaderParamType e) {
  if (e < EShaderParamType_Type_UNKNOWN || e > EShaderParamType_Type_FCOLOR_GRADIENT) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEShaderParamType()[index];
}

enum EPhysicResourceType {
  EPhysicResourceType_PRT_RIGIIDBODY = 0,
  EPhysicResourceType_PRT_RIGIIDBODY_COMPO = 1,
  EPhysicResourceType_PRT_DYNAMIC_COLLSION = 2,
  EPhysicResourceType_MIN = EPhysicResourceType_PRT_RIGIIDBODY,
  EPhysicResourceType_MAX = EPhysicResourceType_PRT_DYNAMIC_COLLSION
};

inline const EPhysicResourceType (&EnumValuesEPhysicResourceType())[3] {
  static const EPhysicResourceType values[] = {
    EPhysicResourceType_PRT_RIGIIDBODY,
    EPhysicResourceType_PRT_RIGIIDBODY_COMPO,
    EPhysicResourceType_PRT_DYNAMIC_COLLSION
  };
  return values;
}

inline const char * const *EnumNamesEPhysicResourceType() {
  static const char * const names[] = {
    "PRT_RIGIIDBODY",
    "PRT_RIGIIDBODY_COMPO",
    "PRT_DYNAMIC_COLLSION",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPhysicResourceType(EPhysicResourceType e) {
  if (e < EPhysicResourceType_PRT_RIGIIDBODY || e > EPhysicResourceType_PRT_DYNAMIC_COLLSION) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPhysicResourceType()[index];
}

enum ECollisionShapeType {
  ECollisionShapeType_ECST_Capsule = 0,
  ECollisionShapeType_ECST_Box = 1,
  ECollisionShapeType_ECST_Sphere = 2,
  ECollisionShapeType_ECST_TriangleMesh = 3,
  ECollisionShapeType_ECST_ConvexMesh = 4,
  ECollisionShapeType_MIN = ECollisionShapeType_ECST_Capsule,
  ECollisionShapeType_MAX = ECollisionShapeType_ECST_ConvexMesh
};

inline const ECollisionShapeType (&EnumValuesECollisionShapeType())[5] {
  static const ECollisionShapeType values[] = {
    ECollisionShapeType_ECST_Capsule,
    ECollisionShapeType_ECST_Box,
    ECollisionShapeType_ECST_Sphere,
    ECollisionShapeType_ECST_TriangleMesh,
    ECollisionShapeType_ECST_ConvexMesh
  };
  return values;
}

inline const char * const *EnumNamesECollisionShapeType() {
  static const char * const names[] = {
    "ECST_Capsule",
    "ECST_Box",
    "ECST_Sphere",
    "ECST_TriangleMesh",
    "ECST_ConvexMesh",
    nullptr
  };
  return names;
}

inline const char *EnumNameECollisionShapeType(ECollisionShapeType e) {
  if (e < ECollisionShapeType_ECST_Capsule || e > ECollisionShapeType_ECST_ConvexMesh) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesECollisionShapeType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) float2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  float2() {
    memset(static_cast<void *>(this), 0, sizeof(float2));
  }
  float2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(float2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) int3 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;

 public:
  int3() {
    memset(static_cast<void *>(this), 0, sizeof(int3));
  }
  int3(int32_t _x, int32_t _y, int32_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(int3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) float3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  float3() {
    memset(static_cast<void *>(this), 0, sizeof(float3));
  }
  float3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(float3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) double3 FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  double3() {
    memset(static_cast<void *>(this), 0, sizeof(double3));
  }
  double3(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(double3, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) float4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  float4() {
    memset(static_cast<void *>(this), 0, sizeof(float4));
  }
  float4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(float4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ubyte4 FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t x_;
  uint8_t y_;
  uint8_t z_;
  uint8_t w_;

 public:
  ubyte4() {
    memset(static_cast<void *>(this), 0, sizeof(ubyte4));
  }
  ubyte4(uint8_t _x, uint8_t _y, uint8_t _z, uint8_t _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  uint8_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  uint8_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  uint8_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  uint8_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(ubyte4, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) byte4 FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t x_;
  int8_t y_;
  int8_t z_;
  int8_t w_;

 public:
  byte4() {
    memset(static_cast<void *>(this), 0, sizeof(byte4));
  }
  byte4(int8_t _x, int8_t _y, int8_t _z, int8_t _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  int8_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int8_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int8_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  int8_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(byte4, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) int4 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;
  int32_t w_;

 public:
  int4() {
    memset(static_cast<void *>(this), 0, sizeof(int4));
  }
  int4(int32_t _x, int32_t _y, int32_t _z, int32_t _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(int4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TinyWeight FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t weight_;

 public:
  TinyWeight() {
    memset(static_cast<void *>(this), 0, sizeof(TinyWeight));
  }
  TinyWeight(uint32_t _weight)
      : weight_(flatbuffers::EndianScalar(_weight)) {
  }
  uint32_t weight() const {
    return flatbuffers::EndianScalar(weight_);
  }
};
FLATBUFFERS_STRUCT_END(TinyWeight, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TinyVector FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t vector_;

 public:
  TinyVector() {
    memset(static_cast<void *>(this), 0, sizeof(TinyVector));
  }
  TinyVector(uint32_t _vector)
      : vector_(flatbuffers::EndianScalar(_vector)) {
  }
  uint32_t vector() const {
    return flatbuffers::EndianScalar(vector_);
  }
};
FLATBUFFERS_STRUCT_END(TinyVector, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TinyTangent FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t tangent_;

 public:
  TinyTangent() {
    memset(static_cast<void *>(this), 0, sizeof(TinyTangent));
  }
  TinyTangent(int32_t _tangent)
      : tangent_(flatbuffers::EndianScalar(_tangent)) {
  }
  int32_t tangent() const {
    return flatbuffers::EndianScalar(tangent_);
  }
};
FLATBUFFERS_STRUCT_END(TinyTangent, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TinyQuaternion FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t quat_;

 public:
  TinyQuaternion() {
    memset(static_cast<void *>(this), 0, sizeof(TinyQuaternion));
  }
  TinyQuaternion(uint32_t _quat)
      : quat_(flatbuffers::EndianScalar(_quat)) {
  }
  uint32_t quat() const {
    return flatbuffers::EndianScalar(quat_);
  }
};
FLATBUFFERS_STRUCT_END(TinyQuaternion, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix FLATBUFFERS_FINAL_CLASS {
 private:
  float m_11_;
  float m_12_;
  float m_13_;
  float m_14_;
  float m_21_;
  float m_22_;
  float m_23_;
  float m_24_;
  float m_31_;
  float m_32_;
  float m_33_;
  float m_34_;
  float m_41_;
  float m_42_;
  float m_43_;
  float m_44_;

 public:
  Matrix() {
    memset(static_cast<void *>(this), 0, sizeof(Matrix));
  }
  Matrix(float _m_11, float _m_12, float _m_13, float _m_14, float _m_21, float _m_22, float _m_23, float _m_24, float _m_31, float _m_32, float _m_33, float _m_34, float _m_41, float _m_42, float _m_43, float _m_44)
      : m_11_(flatbuffers::EndianScalar(_m_11)),
        m_12_(flatbuffers::EndianScalar(_m_12)),
        m_13_(flatbuffers::EndianScalar(_m_13)),
        m_14_(flatbuffers::EndianScalar(_m_14)),
        m_21_(flatbuffers::EndianScalar(_m_21)),
        m_22_(flatbuffers::EndianScalar(_m_22)),
        m_23_(flatbuffers::EndianScalar(_m_23)),
        m_24_(flatbuffers::EndianScalar(_m_24)),
        m_31_(flatbuffers::EndianScalar(_m_31)),
        m_32_(flatbuffers::EndianScalar(_m_32)),
        m_33_(flatbuffers::EndianScalar(_m_33)),
        m_34_(flatbuffers::EndianScalar(_m_34)),
        m_41_(flatbuffers::EndianScalar(_m_41)),
        m_42_(flatbuffers::EndianScalar(_m_42)),
        m_43_(flatbuffers::EndianScalar(_m_43)),
        m_44_(flatbuffers::EndianScalar(_m_44)) {
  }
  float m_11() const {
    return flatbuffers::EndianScalar(m_11_);
  }
  float m_12() const {
    return flatbuffers::EndianScalar(m_12_);
  }
  float m_13() const {
    return flatbuffers::EndianScalar(m_13_);
  }
  float m_14() const {
    return flatbuffers::EndianScalar(m_14_);
  }
  float m_21() const {
    return flatbuffers::EndianScalar(m_21_);
  }
  float m_22() const {
    return flatbuffers::EndianScalar(m_22_);
  }
  float m_23() const {
    return flatbuffers::EndianScalar(m_23_);
  }
  float m_24() const {
    return flatbuffers::EndianScalar(m_24_);
  }
  float m_31() const {
    return flatbuffers::EndianScalar(m_31_);
  }
  float m_32() const {
    return flatbuffers::EndianScalar(m_32_);
  }
  float m_33() const {
    return flatbuffers::EndianScalar(m_33_);
  }
  float m_34() const {
    return flatbuffers::EndianScalar(m_34_);
  }
  float m_41() const {
    return flatbuffers::EndianScalar(m_41_);
  }
  float m_42() const {
    return flatbuffers::EndianScalar(m_42_);
  }
  float m_43() const {
    return flatbuffers::EndianScalar(m_43_);
  }
  float m_44() const {
    return flatbuffers::EndianScalar(m_44_);
  }
};
FLATBUFFERS_STRUCT_END(Matrix, 64);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MapFloatColor FLATBUFFERS_FINAL_CLASS {
 private:
  float key_;
  uint32_t value_;

 public:
  MapFloatColor() {
    memset(static_cast<void *>(this), 0, sizeof(MapFloatColor));
  }
  MapFloatColor(float _key, uint32_t _value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  float key() const {
    return flatbuffers::EndianScalar(key_);
  }
  uint32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(MapFloatColor, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MapFloatUbyte FLATBUFFERS_FINAL_CLASS {
 private:
  float key_;
  uint8_t value_;
  int8_t padding0__;  int16_t padding1__;

 public:
  MapFloatUbyte() {
    memset(static_cast<void *>(this), 0, sizeof(MapFloatUbyte));
  }
  MapFloatUbyte(float _key, uint8_t _value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(flatbuffers::EndianScalar(_value)),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;    (void)padding1__;
  }
  float key() const {
    return flatbuffers::EndianScalar(key_);
  }
  uint8_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(MapFloatUbyte, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MapFloatByte FLATBUFFERS_FINAL_CLASS {
 private:
  float key_;
  int8_t value_;
  int8_t padding0__;  int16_t padding1__;

 public:
  MapFloatByte() {
    memset(static_cast<void *>(this), 0, sizeof(MapFloatByte));
  }
  MapFloatByte(float _key, int8_t _value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(flatbuffers::EndianScalar(_value)),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;    (void)padding1__;
  }
  float key() const {
    return flatbuffers::EndianScalar(key_);
  }
  int8_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(MapFloatByte, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MapFloatUint FLATBUFFERS_FINAL_CLASS {
 private:
  float key_;
  uint32_t value_;

 public:
  MapFloatUint() {
    memset(static_cast<void *>(this), 0, sizeof(MapFloatUint));
  }
  MapFloatUint(float _key, uint32_t _value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  float key() const {
    return flatbuffers::EndianScalar(key_);
  }
  uint32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(MapFloatUint, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MapFloatInt FLATBUFFERS_FINAL_CLASS {
 private:
  float key_;
  int32_t value_;

 public:
  MapFloatInt() {
    memset(static_cast<void *>(this), 0, sizeof(MapFloatInt));
  }
  MapFloatInt(float _key, int32_t _value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  float key() const {
    return flatbuffers::EndianScalar(key_);
  }
  int32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(MapFloatInt, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MapFloatFloat FLATBUFFERS_FINAL_CLASS {
 private:
  float key_;
  float value_;

 public:
  MapFloatFloat() {
    memset(static_cast<void *>(this), 0, sizeof(MapFloatFloat));
  }
  MapFloatFloat(float _key, float _value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  float key() const {
    return flatbuffers::EndianScalar(key_);
  }
  float value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(MapFloatFloat, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MapFloatFloat3 FLATBUFFERS_FINAL_CLASS {
 private:
  float key_;
  float3 value_;

 public:
  MapFloatFloat3() {
    memset(static_cast<void *>(this), 0, sizeof(MapFloatFloat3));
  }
  MapFloatFloat3(float _key, const float3 &_value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(_value) {
  }
  float key() const {
    return flatbuffers::EndianScalar(key_);
  }
  const float3 &value() const {
    return value_;
  }
};
FLATBUFFERS_STRUCT_END(MapFloatFloat3, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MapIntInt FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t key_;
  int32_t value_;

 public:
  MapIntInt() {
    memset(static_cast<void *>(this), 0, sizeof(MapIntInt));
  }
  MapIntInt(int32_t _key, int32_t _value)
      : key_(flatbuffers::EndianScalar(_key)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  int32_t key() const {
    return flatbuffers::EndianScalar(key_);
  }
  int32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(MapIntInt, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) OptUbyte FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t val_;
  int8_t padding0__;  int16_t padding1__;
  int32_t idx_;
  int32_t count_;

 public:
  OptUbyte() {
    memset(static_cast<void *>(this), 0, sizeof(OptUbyte));
  }
  OptUbyte(uint8_t _val, int32_t _idx, int32_t _count)
      : val_(flatbuffers::EndianScalar(_val)),
        padding0__(0),
        padding1__(0),
        idx_(flatbuffers::EndianScalar(_idx)),
        count_(flatbuffers::EndianScalar(_count)) {
    (void)padding0__;    (void)padding1__;
  }
  uint8_t val() const {
    return flatbuffers::EndianScalar(val_);
  }
  int32_t idx() const {
    return flatbuffers::EndianScalar(idx_);
  }
  int32_t count() const {
    return flatbuffers::EndianScalar(count_);
  }
};
FLATBUFFERS_STRUCT_END(OptUbyte, 12);

struct RichCurveKeyT : public flatbuffers::NativeTable {
  typedef RichCurveKey TableType;
  float time;
  float value;
  float leave_tangent;
  float arrive_tangent;
  uint8_t interp_mode;
  RichCurveKeyT()
      : time(0.0f),
        value(0.0f),
        leave_tangent(0.0f),
        arrive_tangent(0.0f),
        interp_mode(0) {
  }
};

struct RichCurveKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RichCurveKeyT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_VALUE = 6,
    VT_LEAVE_TANGENT = 8,
    VT_ARRIVE_TANGENT = 10,
    VT_INTERP_MODE = 12
  };
  float time() const {
    return GetField<float>(VT_TIME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  float leave_tangent() const {
    return GetField<float>(VT_LEAVE_TANGENT, 0.0f);
  }
  float arrive_tangent() const {
    return GetField<float>(VT_ARRIVE_TANGENT, 0.0f);
  }
  uint8_t interp_mode() const {
    return GetField<uint8_t>(VT_INTERP_MODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TIME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<float>(verifier, VT_LEAVE_TANGENT) &&
           VerifyField<float>(verifier, VT_ARRIVE_TANGENT) &&
           VerifyField<uint8_t>(verifier, VT_INTERP_MODE) &&
           verifier.EndTable();
  }
  RichCurveKeyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RichCurveKeyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RichCurveKey> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveKeyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RichCurveKeyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(float time) {
    fbb_.AddElement<float>(RichCurveKey::VT_TIME, time, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(RichCurveKey::VT_VALUE, value, 0.0f);
  }
  void add_leave_tangent(float leave_tangent) {
    fbb_.AddElement<float>(RichCurveKey::VT_LEAVE_TANGENT, leave_tangent, 0.0f);
  }
  void add_arrive_tangent(float arrive_tangent) {
    fbb_.AddElement<float>(RichCurveKey::VT_ARRIVE_TANGENT, arrive_tangent, 0.0f);
  }
  void add_interp_mode(uint8_t interp_mode) {
    fbb_.AddElement<uint8_t>(RichCurveKey::VT_INTERP_MODE, interp_mode, 0);
  }
  explicit RichCurveKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RichCurveKeyBuilder &operator=(const RichCurveKeyBuilder &);
  flatbuffers::Offset<RichCurveKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RichCurveKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<RichCurveKey> CreateRichCurveKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    float time = 0.0f,
    float value = 0.0f,
    float leave_tangent = 0.0f,
    float arrive_tangent = 0.0f,
    uint8_t interp_mode = 0) {
  RichCurveKeyBuilder builder_(_fbb);
  builder_.add_arrive_tangent(arrive_tangent);
  builder_.add_leave_tangent(leave_tangent);
  builder_.add_value(value);
  builder_.add_time(time);
  builder_.add_interp_mode(interp_mode);
  return builder_.Finish();
}

flatbuffers::Offset<RichCurveKey> CreateRichCurveKey(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RichCurveT : public flatbuffers::NativeTable {
  typedef RichCurve TableType;
  std::vector<std::unique_ptr<RichCurveKeyT>> key;
  RichCurveT() {
  }
};

struct RichCurve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RichCurveT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<RichCurveKey>> *key() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RichCurveKey>> *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyVector(key()) &&
           verifier.VerifyVectorOfTables(key()) &&
           verifier.EndTable();
  }
  RichCurveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RichCurveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RichCurve> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RichCurveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RichCurveKey>>> key) {
    fbb_.AddOffset(RichCurve::VT_KEY, key);
  }
  explicit RichCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RichCurveBuilder &operator=(const RichCurveBuilder &);
  flatbuffers::Offset<RichCurve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RichCurve>(end);
    return o;
  }
};

inline flatbuffers::Offset<RichCurve> CreateRichCurve(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RichCurveKey>>> key = 0) {
  RichCurveBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<RichCurve> CreateRichCurveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<RichCurveKey>> *key = nullptr) {
  auto key__ = key ? _fbb.CreateVector<flatbuffers::Offset<RichCurveKey>>(*key) : 0;
  return ArkQnData::CreateRichCurve(
      _fbb,
      key__);
}

flatbuffers::Offset<RichCurve> CreateRichCurve(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RichCurveVectorT : public flatbuffers::NativeTable {
  typedef RichCurveVector TableType;
  std::vector<std::unique_ptr<RichCurveT>> curve;
  RichCurveVectorT() {
  }
};

struct RichCurveVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RichCurveVectorT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURVE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<RichCurve>> *curve() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RichCurve>> *>(VT_CURVE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURVE) &&
           verifier.VerifyVector(curve()) &&
           verifier.VerifyVectorOfTables(curve()) &&
           verifier.EndTable();
  }
  RichCurveVectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RichCurveVectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RichCurveVector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveVectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RichCurveVectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_curve(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RichCurve>>> curve) {
    fbb_.AddOffset(RichCurveVector::VT_CURVE, curve);
  }
  explicit RichCurveVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RichCurveVectorBuilder &operator=(const RichCurveVectorBuilder &);
  flatbuffers::Offset<RichCurveVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RichCurveVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<RichCurveVector> CreateRichCurveVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RichCurve>>> curve = 0) {
  RichCurveVectorBuilder builder_(_fbb);
  builder_.add_curve(curve);
  return builder_.Finish();
}

inline flatbuffers::Offset<RichCurveVector> CreateRichCurveVectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<RichCurve>> *curve = nullptr) {
  auto curve__ = curve ? _fbb.CreateVector<flatbuffers::Offset<RichCurve>>(*curve) : 0;
  return ArkQnData::CreateRichCurveVector(
      _fbb,
      curve__);
}

flatbuffers::Offset<RichCurveVector> CreateRichCurveVector(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveVectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShaderParamValT : public flatbuffers::NativeTable {
  typedef ShaderParamVal TableType;
  bool val_bool;
  int32_t val_int;
  uint32_t val_uint;
  float val_float;
  std::unique_ptr<float4> val_color;
  std::unique_ptr<float2> val_vector2;
  std::unique_ptr<float3> val_vector3;
  std::unique_ptr<float4> val_vector4;
  std::vector<float> val_gradient;
  ShaderParamValT()
      : val_bool(false),
        val_int(0),
        val_uint(0),
        val_float(0.0f) {
  }
};

struct ShaderParamVal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderParamValT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_BOOL = 4,
    VT_VAL_INT = 6,
    VT_VAL_UINT = 8,
    VT_VAL_FLOAT = 10,
    VT_VAL_COLOR = 12,
    VT_VAL_VECTOR2 = 14,
    VT_VAL_VECTOR3 = 16,
    VT_VAL_VECTOR4 = 18,
    VT_VAL_GRADIENT = 20
  };
  bool val_bool() const {
    return GetField<uint8_t>(VT_VAL_BOOL, 0) != 0;
  }
  int32_t val_int() const {
    return GetField<int32_t>(VT_VAL_INT, 0);
  }
  uint32_t val_uint() const {
    return GetField<uint32_t>(VT_VAL_UINT, 0);
  }
  float val_float() const {
    return GetField<float>(VT_VAL_FLOAT, 0.0f);
  }
  const float4 *val_color() const {
    return GetStruct<const float4 *>(VT_VAL_COLOR);
  }
  const float2 *val_vector2() const {
    return GetStruct<const float2 *>(VT_VAL_VECTOR2);
  }
  const float3 *val_vector3() const {
    return GetStruct<const float3 *>(VT_VAL_VECTOR3);
  }
  const float4 *val_vector4() const {
    return GetStruct<const float4 *>(VT_VAL_VECTOR4);
  }
  const flatbuffers::Vector<float> *val_gradient() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VAL_GRADIENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_BOOL) &&
           VerifyField<int32_t>(verifier, VT_VAL_INT) &&
           VerifyField<uint32_t>(verifier, VT_VAL_UINT) &&
           VerifyField<float>(verifier, VT_VAL_FLOAT) &&
           VerifyField<float4>(verifier, VT_VAL_COLOR) &&
           VerifyField<float2>(verifier, VT_VAL_VECTOR2) &&
           VerifyField<float3>(verifier, VT_VAL_VECTOR3) &&
           VerifyField<float4>(verifier, VT_VAL_VECTOR4) &&
           VerifyOffset(verifier, VT_VAL_GRADIENT) &&
           verifier.VerifyVector(val_gradient()) &&
           verifier.EndTable();
  }
  ShaderParamValT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShaderParamValT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShaderParamVal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShaderParamValT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShaderParamValBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_val_bool(bool val_bool) {
    fbb_.AddElement<uint8_t>(ShaderParamVal::VT_VAL_BOOL, static_cast<uint8_t>(val_bool), 0);
  }
  void add_val_int(int32_t val_int) {
    fbb_.AddElement<int32_t>(ShaderParamVal::VT_VAL_INT, val_int, 0);
  }
  void add_val_uint(uint32_t val_uint) {
    fbb_.AddElement<uint32_t>(ShaderParamVal::VT_VAL_UINT, val_uint, 0);
  }
  void add_val_float(float val_float) {
    fbb_.AddElement<float>(ShaderParamVal::VT_VAL_FLOAT, val_float, 0.0f);
  }
  void add_val_color(const float4 *val_color) {
    fbb_.AddStruct(ShaderParamVal::VT_VAL_COLOR, val_color);
  }
  void add_val_vector2(const float2 *val_vector2) {
    fbb_.AddStruct(ShaderParamVal::VT_VAL_VECTOR2, val_vector2);
  }
  void add_val_vector3(const float3 *val_vector3) {
    fbb_.AddStruct(ShaderParamVal::VT_VAL_VECTOR3, val_vector3);
  }
  void add_val_vector4(const float4 *val_vector4) {
    fbb_.AddStruct(ShaderParamVal::VT_VAL_VECTOR4, val_vector4);
  }
  void add_val_gradient(flatbuffers::Offset<flatbuffers::Vector<float>> val_gradient) {
    fbb_.AddOffset(ShaderParamVal::VT_VAL_GRADIENT, val_gradient);
  }
  explicit ShaderParamValBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderParamValBuilder &operator=(const ShaderParamValBuilder &);
  flatbuffers::Offset<ShaderParamVal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderParamVal>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderParamVal> CreateShaderParamVal(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool val_bool = false,
    int32_t val_int = 0,
    uint32_t val_uint = 0,
    float val_float = 0.0f,
    const float4 *val_color = 0,
    const float2 *val_vector2 = 0,
    const float3 *val_vector3 = 0,
    const float4 *val_vector4 = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> val_gradient = 0) {
  ShaderParamValBuilder builder_(_fbb);
  builder_.add_val_gradient(val_gradient);
  builder_.add_val_vector4(val_vector4);
  builder_.add_val_vector3(val_vector3);
  builder_.add_val_vector2(val_vector2);
  builder_.add_val_color(val_color);
  builder_.add_val_float(val_float);
  builder_.add_val_uint(val_uint);
  builder_.add_val_int(val_int);
  builder_.add_val_bool(val_bool);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShaderParamVal> CreateShaderParamValDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool val_bool = false,
    int32_t val_int = 0,
    uint32_t val_uint = 0,
    float val_float = 0.0f,
    const float4 *val_color = 0,
    const float2 *val_vector2 = 0,
    const float3 *val_vector3 = 0,
    const float4 *val_vector4 = 0,
    const std::vector<float> *val_gradient = nullptr) {
  auto val_gradient__ = val_gradient ? _fbb.CreateVector<float>(*val_gradient) : 0;
  return ArkQnData::CreateShaderParamVal(
      _fbb,
      val_bool,
      val_int,
      val_uint,
      val_float,
      val_color,
      val_vector2,
      val_vector3,
      val_vector4,
      val_gradient__);
}

flatbuffers::Offset<ShaderParamVal> CreateShaderParamVal(flatbuffers::FlatBufferBuilder &_fbb, const ShaderParamValT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShaderRenderParamT : public flatbuffers::NativeTable {
  typedef ShaderRenderParam TableType;
  std::string name;
  uint8_t type;
  std::vector<uint8_t> data;
  bool bUseNewParamVal;
  std::unique_ptr<ShaderParamValT> dataNew;
  ShaderRenderParamT()
      : type(0),
        bUseNewParamVal(false) {
  }
};

struct ShaderRenderParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderRenderParamT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DATA = 8,
    VT_BUSENEWPARAMVAL = 10,
    VT_DATANEW = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool bUseNewParamVal() const {
    return GetField<uint8_t>(VT_BUSENEWPARAMVAL, 0) != 0;
  }
  const ShaderParamVal *dataNew() const {
    return GetPointer<const ShaderParamVal *>(VT_DATANEW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint8_t>(verifier, VT_BUSENEWPARAMVAL) &&
           VerifyOffset(verifier, VT_DATANEW) &&
           verifier.VerifyTable(dataNew()) &&
           verifier.EndTable();
  }
  ShaderRenderParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShaderRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShaderRenderParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShaderRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShaderRenderParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ShaderRenderParam::VT_NAME, name);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(ShaderRenderParam::VT_TYPE, type, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ShaderRenderParam::VT_DATA, data);
  }
  void add_bUseNewParamVal(bool bUseNewParamVal) {
    fbb_.AddElement<uint8_t>(ShaderRenderParam::VT_BUSENEWPARAMVAL, static_cast<uint8_t>(bUseNewParamVal), 0);
  }
  void add_dataNew(flatbuffers::Offset<ShaderParamVal> dataNew) {
    fbb_.AddOffset(ShaderRenderParam::VT_DATANEW, dataNew);
  }
  explicit ShaderRenderParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderRenderParamBuilder &operator=(const ShaderRenderParamBuilder &);
  flatbuffers::Offset<ShaderRenderParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderRenderParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderRenderParam> CreateShaderRenderParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    bool bUseNewParamVal = false,
    flatbuffers::Offset<ShaderParamVal> dataNew = 0) {
  ShaderRenderParamBuilder builder_(_fbb);
  builder_.add_dataNew(dataNew);
  builder_.add_data(data);
  builder_.add_name(name);
  builder_.add_bUseNewParamVal(bUseNewParamVal);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShaderRenderParam> CreateShaderRenderParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t type = 0,
    const std::vector<uint8_t> *data = nullptr,
    bool bUseNewParamVal = false,
    flatbuffers::Offset<ShaderParamVal> dataNew = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return ArkQnData::CreateShaderRenderParam(
      _fbb,
      name__,
      type,
      data__,
      bUseNewParamVal,
      dataNew);
}

flatbuffers::Offset<ShaderRenderParam> CreateShaderRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const ShaderRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TextureRenderParamT : public flatbuffers::NativeTable {
  typedef TextureRenderParam TableType;
  int32_t slot;
  std::string path;
  ETextureFilterType filter;
  bool srgb;
  ETextureAddress addressMode;
  TextureRenderParamT()
      : slot(0),
        filter(ETextureFilterType_FT_ANISOTROPIC),
        srgb(true),
        addressMode(ETextureAddress_TA_WRAP) {
  }
};

struct TextureRenderParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureRenderParamT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOT = 4,
    VT_PATH = 6,
    VT_FILTER = 8,
    VT_SRGB = 10,
    VT_ADDRESSMODE = 12
  };
  int32_t slot() const {
    return GetField<int32_t>(VT_SLOT, 0);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  ETextureFilterType filter() const {
    return static_cast<ETextureFilterType>(GetField<int8_t>(VT_FILTER, 3));
  }
  bool srgb() const {
    return GetField<uint8_t>(VT_SRGB, 1) != 0;
  }
  ETextureAddress addressMode() const {
    return static_cast<ETextureAddress>(GetField<int8_t>(VT_ADDRESSMODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SLOT) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<int8_t>(verifier, VT_FILTER) &&
           VerifyField<uint8_t>(verifier, VT_SRGB) &&
           VerifyField<int8_t>(verifier, VT_ADDRESSMODE) &&
           verifier.EndTable();
  }
  TextureRenderParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextureRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TextureRenderParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextureRenderParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(int32_t slot) {
    fbb_.AddElement<int32_t>(TextureRenderParam::VT_SLOT, slot, 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(TextureRenderParam::VT_PATH, path);
  }
  void add_filter(ETextureFilterType filter) {
    fbb_.AddElement<int8_t>(TextureRenderParam::VT_FILTER, static_cast<int8_t>(filter), 3);
  }
  void add_srgb(bool srgb) {
    fbb_.AddElement<uint8_t>(TextureRenderParam::VT_SRGB, static_cast<uint8_t>(srgb), 1);
  }
  void add_addressMode(ETextureAddress addressMode) {
    fbb_.AddElement<int8_t>(TextureRenderParam::VT_ADDRESSMODE, static_cast<int8_t>(addressMode), 0);
  }
  explicit TextureRenderParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureRenderParamBuilder &operator=(const TextureRenderParamBuilder &);
  flatbuffers::Offset<TextureRenderParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureRenderParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureRenderParam> CreateTextureRenderParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slot = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    ETextureFilterType filter = ETextureFilterType_FT_ANISOTROPIC,
    bool srgb = true,
    ETextureAddress addressMode = ETextureAddress_TA_WRAP) {
  TextureRenderParamBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_slot(slot);
  builder_.add_addressMode(addressMode);
  builder_.add_srgb(srgb);
  builder_.add_filter(filter);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextureRenderParam> CreateTextureRenderParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slot = 0,
    const char *path = nullptr,
    ETextureFilterType filter = ETextureFilterType_FT_ANISOTROPIC,
    bool srgb = true,
    ETextureAddress addressMode = ETextureAddress_TA_WRAP) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return ArkQnData::CreateTextureRenderParam(
      _fbb,
      slot,
      path__,
      filter,
      srgb,
      addressMode);
}

flatbuffers::Offset<TextureRenderParam> CreateTextureRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const TextureRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PieceRenderParamT : public flatbuffers::NativeTable {
  typedef PieceRenderParam TableType;
  std::string name;
  uint8_t rs;
  std::vector<std::unique_ptr<ShaderRenderParamT>> shader_param0;
  std::vector<std::unique_ptr<ShaderRenderParamT>> shader_param1;
  std::vector<std::unique_ptr<ShaderRenderParamT>> shader_param2;
  std::vector<std::unique_ptr<ShaderRenderParamT>> shader_param3;
  std::vector<std::unique_ptr<TextureRenderParamT>> texture;
  PieceRenderParamT()
      : rs(0) {
  }
};

struct PieceRenderParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PieceRenderParamT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_RS = 6,
    VT_SHADER_PARAM0 = 8,
    VT_SHADER_PARAM1 = 10,
    VT_SHADER_PARAM2 = 12,
    VT_SHADER_PARAM3 = 14,
    VT_TEXTURE = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t rs() const {
    return GetField<uint8_t>(VT_RS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>> *shader_param0() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>> *>(VT_SHADER_PARAM0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>> *shader_param1() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>> *>(VT_SHADER_PARAM1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>> *shader_param2() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>> *>(VT_SHADER_PARAM2);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>> *shader_param3() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>> *>(VT_SHADER_PARAM3);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TextureRenderParam>> *texture() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TextureRenderParam>> *>(VT_TEXTURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_RS) &&
           VerifyOffset(verifier, VT_SHADER_PARAM0) &&
           verifier.VerifyVector(shader_param0()) &&
           verifier.VerifyVectorOfTables(shader_param0()) &&
           VerifyOffset(verifier, VT_SHADER_PARAM1) &&
           verifier.VerifyVector(shader_param1()) &&
           verifier.VerifyVectorOfTables(shader_param1()) &&
           VerifyOffset(verifier, VT_SHADER_PARAM2) &&
           verifier.VerifyVector(shader_param2()) &&
           verifier.VerifyVectorOfTables(shader_param2()) &&
           VerifyOffset(verifier, VT_SHADER_PARAM3) &&
           verifier.VerifyVector(shader_param3()) &&
           verifier.VerifyVectorOfTables(shader_param3()) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.VerifyVector(texture()) &&
           verifier.VerifyVectorOfTables(texture()) &&
           verifier.EndTable();
  }
  PieceRenderParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PieceRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PieceRenderParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PieceRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PieceRenderParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PieceRenderParam::VT_NAME, name);
  }
  void add_rs(uint8_t rs) {
    fbb_.AddElement<uint8_t>(PieceRenderParam::VT_RS, rs, 0);
  }
  void add_shader_param0(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>>> shader_param0) {
    fbb_.AddOffset(PieceRenderParam::VT_SHADER_PARAM0, shader_param0);
  }
  void add_shader_param1(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>>> shader_param1) {
    fbb_.AddOffset(PieceRenderParam::VT_SHADER_PARAM1, shader_param1);
  }
  void add_shader_param2(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>>> shader_param2) {
    fbb_.AddOffset(PieceRenderParam::VT_SHADER_PARAM2, shader_param2);
  }
  void add_shader_param3(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>>> shader_param3) {
    fbb_.AddOffset(PieceRenderParam::VT_SHADER_PARAM3, shader_param3);
  }
  void add_texture(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TextureRenderParam>>> texture) {
    fbb_.AddOffset(PieceRenderParam::VT_TEXTURE, texture);
  }
  explicit PieceRenderParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PieceRenderParamBuilder &operator=(const PieceRenderParamBuilder &);
  flatbuffers::Offset<PieceRenderParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PieceRenderParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<PieceRenderParam> CreatePieceRenderParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t rs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>>> shader_param0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>>> shader_param1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>>> shader_param2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderRenderParam>>> shader_param3 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TextureRenderParam>>> texture = 0) {
  PieceRenderParamBuilder builder_(_fbb);
  builder_.add_texture(texture);
  builder_.add_shader_param3(shader_param3);
  builder_.add_shader_param2(shader_param2);
  builder_.add_shader_param1(shader_param1);
  builder_.add_shader_param0(shader_param0);
  builder_.add_name(name);
  builder_.add_rs(rs);
  return builder_.Finish();
}

inline flatbuffers::Offset<PieceRenderParam> CreatePieceRenderParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t rs = 0,
    const std::vector<flatbuffers::Offset<ShaderRenderParam>> *shader_param0 = nullptr,
    const std::vector<flatbuffers::Offset<ShaderRenderParam>> *shader_param1 = nullptr,
    const std::vector<flatbuffers::Offset<ShaderRenderParam>> *shader_param2 = nullptr,
    const std::vector<flatbuffers::Offset<ShaderRenderParam>> *shader_param3 = nullptr,
    const std::vector<flatbuffers::Offset<TextureRenderParam>> *texture = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shader_param0__ = shader_param0 ? _fbb.CreateVector<flatbuffers::Offset<ShaderRenderParam>>(*shader_param0) : 0;
  auto shader_param1__ = shader_param1 ? _fbb.CreateVector<flatbuffers::Offset<ShaderRenderParam>>(*shader_param1) : 0;
  auto shader_param2__ = shader_param2 ? _fbb.CreateVector<flatbuffers::Offset<ShaderRenderParam>>(*shader_param2) : 0;
  auto shader_param3__ = shader_param3 ? _fbb.CreateVector<flatbuffers::Offset<ShaderRenderParam>>(*shader_param3) : 0;
  auto texture__ = texture ? _fbb.CreateVector<flatbuffers::Offset<TextureRenderParam>>(*texture) : 0;
  return ArkQnData::CreatePieceRenderParam(
      _fbb,
      name__,
      rs,
      shader_param0__,
      shader_param1__,
      shader_param2__,
      shader_param3__,
      texture__);
}

flatbuffers::Offset<PieceRenderParam> CreatePieceRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const PieceRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArpRenderParamT : public flatbuffers::NativeTable {
  typedef ArpRenderParam TableType;
  uint8_t child_level;
  uint8_t sibling_level;
  uint8_t rs_idx_for_all_piece;
  std::vector<std::unique_ptr<PieceRenderParamT>> param;
  std::string arp;
  ArpRenderParamT()
      : child_level(255),
        sibling_level(255),
        rs_idx_for_all_piece(255) {
  }
};

struct ArpRenderParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArpRenderParamT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHILD_LEVEL = 4,
    VT_SIBLING_LEVEL = 6,
    VT_RS_IDX_FOR_ALL_PIECE = 8,
    VT_PARAM = 10,
    VT_ARP = 12
  };
  uint8_t child_level() const {
    return GetField<uint8_t>(VT_CHILD_LEVEL, 255);
  }
  uint8_t sibling_level() const {
    return GetField<uint8_t>(VT_SIBLING_LEVEL, 255);
  }
  uint8_t rs_idx_for_all_piece() const {
    return GetField<uint8_t>(VT_RS_IDX_FOR_ALL_PIECE, 255);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PieceRenderParam>> *param() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PieceRenderParam>> *>(VT_PARAM);
  }
  const flatbuffers::String *arp() const {
    return GetPointer<const flatbuffers::String *>(VT_ARP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CHILD_LEVEL) &&
           VerifyField<uint8_t>(verifier, VT_SIBLING_LEVEL) &&
           VerifyField<uint8_t>(verifier, VT_RS_IDX_FOR_ALL_PIECE) &&
           VerifyOffset(verifier, VT_PARAM) &&
           verifier.VerifyVector(param()) &&
           verifier.VerifyVectorOfTables(param()) &&
           VerifyOffset(verifier, VT_ARP) &&
           verifier.VerifyString(arp()) &&
           verifier.EndTable();
  }
  ArpRenderParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArpRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArpRenderParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArpRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArpRenderParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_child_level(uint8_t child_level) {
    fbb_.AddElement<uint8_t>(ArpRenderParam::VT_CHILD_LEVEL, child_level, 255);
  }
  void add_sibling_level(uint8_t sibling_level) {
    fbb_.AddElement<uint8_t>(ArpRenderParam::VT_SIBLING_LEVEL, sibling_level, 255);
  }
  void add_rs_idx_for_all_piece(uint8_t rs_idx_for_all_piece) {
    fbb_.AddElement<uint8_t>(ArpRenderParam::VT_RS_IDX_FOR_ALL_PIECE, rs_idx_for_all_piece, 255);
  }
  void add_param(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PieceRenderParam>>> param) {
    fbb_.AddOffset(ArpRenderParam::VT_PARAM, param);
  }
  void add_arp(flatbuffers::Offset<flatbuffers::String> arp) {
    fbb_.AddOffset(ArpRenderParam::VT_ARP, arp);
  }
  explicit ArpRenderParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArpRenderParamBuilder &operator=(const ArpRenderParamBuilder &);
  flatbuffers::Offset<ArpRenderParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArpRenderParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArpRenderParam> CreateArpRenderParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t child_level = 255,
    uint8_t sibling_level = 255,
    uint8_t rs_idx_for_all_piece = 255,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PieceRenderParam>>> param = 0,
    flatbuffers::Offset<flatbuffers::String> arp = 0) {
  ArpRenderParamBuilder builder_(_fbb);
  builder_.add_arp(arp);
  builder_.add_param(param);
  builder_.add_rs_idx_for_all_piece(rs_idx_for_all_piece);
  builder_.add_sibling_level(sibling_level);
  builder_.add_child_level(child_level);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArpRenderParam> CreateArpRenderParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t child_level = 255,
    uint8_t sibling_level = 255,
    uint8_t rs_idx_for_all_piece = 255,
    const std::vector<flatbuffers::Offset<PieceRenderParam>> *param = nullptr,
    const char *arp = nullptr) {
  auto param__ = param ? _fbb.CreateVector<flatbuffers::Offset<PieceRenderParam>>(*param) : 0;
  auto arp__ = arp ? _fbb.CreateString(arp) : 0;
  return ArkQnData::CreateArpRenderParam(
      _fbb,
      child_level,
      sibling_level,
      rs_idx_for_all_piece,
      param__,
      arp__);
}

flatbuffers::Offset<ArpRenderParam> CreateArpRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const ArpRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PrefabRenderParamT : public flatbuffers::NativeTable {
  typedef PrefabRenderParam TableType;
  int32_t terrain_blend_tex;
  float terrain_height_diff_x;
  float terrain_height_diff_y;
  float terrain_normal_blend_area;
  std::vector<std::unique_ptr<ArpRenderParamT>> param;
  PrefabRenderParamT()
      : terrain_blend_tex(-1),
        terrain_height_diff_x(0.0f),
        terrain_height_diff_y(0.0f),
        terrain_normal_blend_area(0.0f) {
  }
};

struct PrefabRenderParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PrefabRenderParamT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TERRAIN_BLEND_TEX = 4,
    VT_TERRAIN_HEIGHT_DIFF_X = 6,
    VT_TERRAIN_HEIGHT_DIFF_Y = 8,
    VT_TERRAIN_NORMAL_BLEND_AREA = 10,
    VT_PARAM = 12
  };
  int32_t terrain_blend_tex() const {
    return GetField<int32_t>(VT_TERRAIN_BLEND_TEX, -1);
  }
  float terrain_height_diff_x() const {
    return GetField<float>(VT_TERRAIN_HEIGHT_DIFF_X, 0.0f);
  }
  float terrain_height_diff_y() const {
    return GetField<float>(VT_TERRAIN_HEIGHT_DIFF_Y, 0.0f);
  }
  float terrain_normal_blend_area() const {
    return GetField<float>(VT_TERRAIN_NORMAL_BLEND_AREA, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ArpRenderParam>> *param() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArpRenderParam>> *>(VT_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TERRAIN_BLEND_TEX) &&
           VerifyField<float>(verifier, VT_TERRAIN_HEIGHT_DIFF_X) &&
           VerifyField<float>(verifier, VT_TERRAIN_HEIGHT_DIFF_Y) &&
           VerifyField<float>(verifier, VT_TERRAIN_NORMAL_BLEND_AREA) &&
           VerifyOffset(verifier, VT_PARAM) &&
           verifier.VerifyVector(param()) &&
           verifier.VerifyVectorOfTables(param()) &&
           verifier.EndTable();
  }
  PrefabRenderParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PrefabRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PrefabRenderParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrefabRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PrefabRenderParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_terrain_blend_tex(int32_t terrain_blend_tex) {
    fbb_.AddElement<int32_t>(PrefabRenderParam::VT_TERRAIN_BLEND_TEX, terrain_blend_tex, -1);
  }
  void add_terrain_height_diff_x(float terrain_height_diff_x) {
    fbb_.AddElement<float>(PrefabRenderParam::VT_TERRAIN_HEIGHT_DIFF_X, terrain_height_diff_x, 0.0f);
  }
  void add_terrain_height_diff_y(float terrain_height_diff_y) {
    fbb_.AddElement<float>(PrefabRenderParam::VT_TERRAIN_HEIGHT_DIFF_Y, terrain_height_diff_y, 0.0f);
  }
  void add_terrain_normal_blend_area(float terrain_normal_blend_area) {
    fbb_.AddElement<float>(PrefabRenderParam::VT_TERRAIN_NORMAL_BLEND_AREA, terrain_normal_blend_area, 0.0f);
  }
  void add_param(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArpRenderParam>>> param) {
    fbb_.AddOffset(PrefabRenderParam::VT_PARAM, param);
  }
  explicit PrefabRenderParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrefabRenderParamBuilder &operator=(const PrefabRenderParamBuilder &);
  flatbuffers::Offset<PrefabRenderParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PrefabRenderParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<PrefabRenderParam> CreatePrefabRenderParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t terrain_blend_tex = -1,
    float terrain_height_diff_x = 0.0f,
    float terrain_height_diff_y = 0.0f,
    float terrain_normal_blend_area = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArpRenderParam>>> param = 0) {
  PrefabRenderParamBuilder builder_(_fbb);
  builder_.add_param(param);
  builder_.add_terrain_normal_blend_area(terrain_normal_blend_area);
  builder_.add_terrain_height_diff_y(terrain_height_diff_y);
  builder_.add_terrain_height_diff_x(terrain_height_diff_x);
  builder_.add_terrain_blend_tex(terrain_blend_tex);
  return builder_.Finish();
}

inline flatbuffers::Offset<PrefabRenderParam> CreatePrefabRenderParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t terrain_blend_tex = -1,
    float terrain_height_diff_x = 0.0f,
    float terrain_height_diff_y = 0.0f,
    float terrain_normal_blend_area = 0.0f,
    const std::vector<flatbuffers::Offset<ArpRenderParam>> *param = nullptr) {
  auto param__ = param ? _fbb.CreateVector<flatbuffers::Offset<ArpRenderParam>>(*param) : 0;
  return ArkQnData::CreatePrefabRenderParam(
      _fbb,
      terrain_blend_tex,
      terrain_height_diff_x,
      terrain_height_diff_y,
      terrain_normal_blend_area,
      param__);
}

flatbuffers::Offset<PrefabRenderParam> CreatePrefabRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const PrefabRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline RichCurveKeyT *RichCurveKey::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RichCurveKeyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RichCurveKey::UnPackTo(RichCurveKeyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time(); _o->time = _e; };
  { auto _e = value(); _o->value = _e; };
  { auto _e = leave_tangent(); _o->leave_tangent = _e; };
  { auto _e = arrive_tangent(); _o->arrive_tangent = _e; };
  { auto _e = interp_mode(); _o->interp_mode = _e; };
}

inline flatbuffers::Offset<RichCurveKey> RichCurveKey::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveKeyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRichCurveKey(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RichCurveKey> CreateRichCurveKey(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RichCurveKeyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time = _o->time;
  auto _value = _o->value;
  auto _leave_tangent = _o->leave_tangent;
  auto _arrive_tangent = _o->arrive_tangent;
  auto _interp_mode = _o->interp_mode;
  return ArkQnData::CreateRichCurveKey(
      _fbb,
      _time,
      _value,
      _leave_tangent,
      _arrive_tangent,
      _interp_mode);
}

inline RichCurveT *RichCurve::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RichCurveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RichCurve::UnPackTo(RichCurveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) { _o->key.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->key[_i] = std::unique_ptr<RichCurveKeyT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<RichCurve> RichCurve::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRichCurve(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RichCurve> CreateRichCurve(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RichCurveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _o->key.size() ? _fbb.CreateVector<flatbuffers::Offset<RichCurveKey>> (_o->key.size(), [](size_t i, _VectorArgs *__va) { return CreateRichCurveKey(*__va->__fbb, __va->__o->key[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ArkQnData::CreateRichCurve(
      _fbb,
      _key);
}

inline RichCurveVectorT *RichCurveVector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RichCurveVectorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RichCurveVector::UnPackTo(RichCurveVectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = curve(); if (_e) { _o->curve.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->curve[_i] = std::unique_ptr<RichCurveT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<RichCurveVector> RichCurveVector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveVectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRichCurveVector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RichCurveVector> CreateRichCurveVector(flatbuffers::FlatBufferBuilder &_fbb, const RichCurveVectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RichCurveVectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _curve = _o->curve.size() ? _fbb.CreateVector<flatbuffers::Offset<RichCurve>> (_o->curve.size(), [](size_t i, _VectorArgs *__va) { return CreateRichCurve(*__va->__fbb, __va->__o->curve[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ArkQnData::CreateRichCurveVector(
      _fbb,
      _curve);
}

inline ShaderParamValT *ShaderParamVal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShaderParamValT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ShaderParamVal::UnPackTo(ShaderParamValT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val_bool(); _o->val_bool = _e; };
  { auto _e = val_int(); _o->val_int = _e; };
  { auto _e = val_uint(); _o->val_uint = _e; };
  { auto _e = val_float(); _o->val_float = _e; };
  { auto _e = val_color(); if (_e) _o->val_color = std::unique_ptr<float4>(new float4(*_e)); };
  { auto _e = val_vector2(); if (_e) _o->val_vector2 = std::unique_ptr<float2>(new float2(*_e)); };
  { auto _e = val_vector3(); if (_e) _o->val_vector3 = std::unique_ptr<float3>(new float3(*_e)); };
  { auto _e = val_vector4(); if (_e) _o->val_vector4 = std::unique_ptr<float4>(new float4(*_e)); };
  { auto _e = val_gradient(); if (_e) { _o->val_gradient.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->val_gradient[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<ShaderParamVal> ShaderParamVal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShaderParamValT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShaderParamVal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShaderParamVal> CreateShaderParamVal(flatbuffers::FlatBufferBuilder &_fbb, const ShaderParamValT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShaderParamValT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val_bool = _o->val_bool;
  auto _val_int = _o->val_int;
  auto _val_uint = _o->val_uint;
  auto _val_float = _o->val_float;
  auto _val_color = _o->val_color ? _o->val_color.get() : 0;
  auto _val_vector2 = _o->val_vector2 ? _o->val_vector2.get() : 0;
  auto _val_vector3 = _o->val_vector3 ? _o->val_vector3.get() : 0;
  auto _val_vector4 = _o->val_vector4 ? _o->val_vector4.get() : 0;
  auto _val_gradient = _o->val_gradient.size() ? _fbb.CreateVector(_o->val_gradient) : 0;
  return ArkQnData::CreateShaderParamVal(
      _fbb,
      _val_bool,
      _val_int,
      _val_uint,
      _val_float,
      _val_color,
      _val_vector2,
      _val_vector3,
      _val_vector4,
      _val_gradient);
}

inline ShaderRenderParamT *ShaderRenderParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShaderRenderParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ShaderRenderParam::UnPackTo(ShaderRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = type(); _o->type = _e; };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
  { auto _e = bUseNewParamVal(); _o->bUseNewParamVal = _e; };
  { auto _e = dataNew(); if (_e) _o->dataNew = std::unique_ptr<ShaderParamValT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ShaderRenderParam> ShaderRenderParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShaderRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShaderRenderParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShaderRenderParam> CreateShaderRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const ShaderRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShaderRenderParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  auto _bUseNewParamVal = _o->bUseNewParamVal;
  auto _dataNew = _o->dataNew ? CreateShaderParamVal(_fbb, _o->dataNew.get(), _rehasher) : 0;
  return ArkQnData::CreateShaderRenderParam(
      _fbb,
      _name,
      _type,
      _data,
      _bUseNewParamVal,
      _dataNew);
}

inline TextureRenderParamT *TextureRenderParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TextureRenderParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TextureRenderParam::UnPackTo(TextureRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = path(); if (_e) _o->path = _e->str(); };
  { auto _e = filter(); _o->filter = _e; };
  { auto _e = srgb(); _o->srgb = _e; };
  { auto _e = addressMode(); _o->addressMode = _e; };
}

inline flatbuffers::Offset<TextureRenderParam> TextureRenderParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTextureRenderParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TextureRenderParam> CreateTextureRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const TextureRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TextureRenderParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _path = _o->path.empty() ? 0 : _fbb.CreateString(_o->path);
  auto _filter = _o->filter;
  auto _srgb = _o->srgb;
  auto _addressMode = _o->addressMode;
  return ArkQnData::CreateTextureRenderParam(
      _fbb,
      _slot,
      _path,
      _filter,
      _srgb,
      _addressMode);
}

inline PieceRenderParamT *PieceRenderParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PieceRenderParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PieceRenderParam::UnPackTo(PieceRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = rs(); _o->rs = _e; };
  { auto _e = shader_param0(); if (_e) { _o->shader_param0.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shader_param0[_i] = std::unique_ptr<ShaderRenderParamT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = shader_param1(); if (_e) { _o->shader_param1.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shader_param1[_i] = std::unique_ptr<ShaderRenderParamT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = shader_param2(); if (_e) { _o->shader_param2.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shader_param2[_i] = std::unique_ptr<ShaderRenderParamT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = shader_param3(); if (_e) { _o->shader_param3.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shader_param3[_i] = std::unique_ptr<ShaderRenderParamT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = texture(); if (_e) { _o->texture.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->texture[_i] = std::unique_ptr<TextureRenderParamT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<PieceRenderParam> PieceRenderParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PieceRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePieceRenderParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PieceRenderParam> CreatePieceRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const PieceRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PieceRenderParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _rs = _o->rs;
  auto _shader_param0 = _o->shader_param0.size() ? _fbb.CreateVector<flatbuffers::Offset<ShaderRenderParam>> (_o->shader_param0.size(), [](size_t i, _VectorArgs *__va) { return CreateShaderRenderParam(*__va->__fbb, __va->__o->shader_param0[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _shader_param1 = _o->shader_param1.size() ? _fbb.CreateVector<flatbuffers::Offset<ShaderRenderParam>> (_o->shader_param1.size(), [](size_t i, _VectorArgs *__va) { return CreateShaderRenderParam(*__va->__fbb, __va->__o->shader_param1[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _shader_param2 = _o->shader_param2.size() ? _fbb.CreateVector<flatbuffers::Offset<ShaderRenderParam>> (_o->shader_param2.size(), [](size_t i, _VectorArgs *__va) { return CreateShaderRenderParam(*__va->__fbb, __va->__o->shader_param2[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _shader_param3 = _o->shader_param3.size() ? _fbb.CreateVector<flatbuffers::Offset<ShaderRenderParam>> (_o->shader_param3.size(), [](size_t i, _VectorArgs *__va) { return CreateShaderRenderParam(*__va->__fbb, __va->__o->shader_param3[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _texture = _o->texture.size() ? _fbb.CreateVector<flatbuffers::Offset<TextureRenderParam>> (_o->texture.size(), [](size_t i, _VectorArgs *__va) { return CreateTextureRenderParam(*__va->__fbb, __va->__o->texture[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ArkQnData::CreatePieceRenderParam(
      _fbb,
      _name,
      _rs,
      _shader_param0,
      _shader_param1,
      _shader_param2,
      _shader_param3,
      _texture);
}

inline ArpRenderParamT *ArpRenderParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArpRenderParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArpRenderParam::UnPackTo(ArpRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = child_level(); _o->child_level = _e; };
  { auto _e = sibling_level(); _o->sibling_level = _e; };
  { auto _e = rs_idx_for_all_piece(); _o->rs_idx_for_all_piece = _e; };
  { auto _e = param(); if (_e) { _o->param.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->param[_i] = std::unique_ptr<PieceRenderParamT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = arp(); if (_e) _o->arp = _e->str(); };
}

inline flatbuffers::Offset<ArpRenderParam> ArpRenderParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArpRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArpRenderParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArpRenderParam> CreateArpRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const ArpRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArpRenderParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _child_level = _o->child_level;
  auto _sibling_level = _o->sibling_level;
  auto _rs_idx_for_all_piece = _o->rs_idx_for_all_piece;
  auto _param = _o->param.size() ? _fbb.CreateVector<flatbuffers::Offset<PieceRenderParam>> (_o->param.size(), [](size_t i, _VectorArgs *__va) { return CreatePieceRenderParam(*__va->__fbb, __va->__o->param[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _arp = _o->arp.empty() ? 0 : _fbb.CreateString(_o->arp);
  return ArkQnData::CreateArpRenderParam(
      _fbb,
      _child_level,
      _sibling_level,
      _rs_idx_for_all_piece,
      _param,
      _arp);
}

inline PrefabRenderParamT *PrefabRenderParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PrefabRenderParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PrefabRenderParam::UnPackTo(PrefabRenderParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = terrain_blend_tex(); _o->terrain_blend_tex = _e; };
  { auto _e = terrain_height_diff_x(); _o->terrain_height_diff_x = _e; };
  { auto _e = terrain_height_diff_y(); _o->terrain_height_diff_y = _e; };
  { auto _e = terrain_normal_blend_area(); _o->terrain_normal_blend_area = _e; };
  { auto _e = param(); if (_e) { _o->param.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->param[_i] = std::unique_ptr<ArpRenderParamT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<PrefabRenderParam> PrefabRenderParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrefabRenderParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePrefabRenderParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PrefabRenderParam> CreatePrefabRenderParam(flatbuffers::FlatBufferBuilder &_fbb, const PrefabRenderParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PrefabRenderParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _terrain_blend_tex = _o->terrain_blend_tex;
  auto _terrain_height_diff_x = _o->terrain_height_diff_x;
  auto _terrain_height_diff_y = _o->terrain_height_diff_y;
  auto _terrain_normal_blend_area = _o->terrain_normal_blend_area;
  auto _param = _o->param.size() ? _fbb.CreateVector<flatbuffers::Offset<ArpRenderParam>> (_o->param.size(), [](size_t i, _VectorArgs *__va) { return CreateArpRenderParam(*__va->__fbb, __va->__o->param[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ArkQnData::CreatePrefabRenderParam(
      _fbb,
      _terrain_blend_tex,
      _terrain_height_diff_x,
      _terrain_height_diff_y,
      _terrain_normal_blend_area,
      _param);
}

}  // namespace ArkQnData

#endif  // FLATBUFFERS_GENERATED_COMMONQN_ARKQNDATA_H_
