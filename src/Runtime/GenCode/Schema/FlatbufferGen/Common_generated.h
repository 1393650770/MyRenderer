// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_MXRENDER_DATA_H_
#define FLATBUFFERS_GENERATED_COMMON_MXRENDER_DATA_H_

#include "flatbuffers/flatbuffers.h"

namespace MXRender {
namespace Data {

struct Vec3;

struct Vec4;

struct Matrix_Row;

struct Matrix_Column;

struct Transform;

bool operator==(const Vec3 &lhs, const Vec3 &rhs);
bool operator!=(const Vec3 &lhs, const Vec3 &rhs);
bool operator==(const Vec4 &lhs, const Vec4 &rhs);
bool operator!=(const Vec4 &lhs, const Vec4 &rhs);
bool operator==(const Matrix_Row &lhs, const Matrix_Row &rhs);
bool operator!=(const Matrix_Row &lhs, const Matrix_Row &rhs);
bool operator==(const Matrix_Column &lhs, const Matrix_Column &rhs);
bool operator!=(const Matrix_Column &lhs, const Matrix_Column &rhs);
bool operator==(const Transform &lhs, const Transform &rhs);
bool operator!=(const Transform &lhs, const Transform &rhs);

inline const flatbuffers::TypeTable *Vec3TypeTable();

inline const flatbuffers::TypeTable *Vec4TypeTable();

inline const flatbuffers::TypeTable *Matrix_RowTypeTable();

inline const flatbuffers::TypeTable *Matrix_ColumnTypeTable();

inline const flatbuffers::TypeTable *TransformTypeTable();

enum Matrix {
  Matrix_NONE = 0,
  Matrix_Matrix_Column = 1,
  Matrix_Matrix_Row = 2,
  Matrix_MIN = Matrix_NONE,
  Matrix_MAX = Matrix_Matrix_Row
};

inline const Matrix (&EnumValuesMatrix())[3] {
  static const Matrix values[] = {
    Matrix_NONE,
    Matrix_Matrix_Column,
    Matrix_Matrix_Row
  };
  return values;
}

inline const char * const *EnumNamesMatrix() {
  static const char * const names[4] = {
    "NONE",
    "Matrix_Column",
    "Matrix_Row",
    nullptr
  };
  return names;
}

inline const char *EnumNameMatrix(Matrix e) {
  if (flatbuffers::IsOutRange(e, Matrix_NONE, Matrix_Matrix_Row)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMatrix()[index];
}

template<typename T> struct MatrixTraits {
  static const Matrix enum_value = Matrix_NONE;
};

template<> struct MatrixTraits<MXRender::Data::Matrix_Column> {
  static const Matrix enum_value = Matrix_Matrix_Column;
};

template<> struct MatrixTraits<MXRender::Data::Matrix_Row> {
  static const Matrix enum_value = Matrix_Matrix_Row;
};

struct MatrixUnion {
  Matrix type;
  void *value;

  MatrixUnion() : type(Matrix_NONE), value(nullptr) {}
  MatrixUnion(MatrixUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Matrix_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MatrixUnion(const MatrixUnion &);
  MatrixUnion &operator=(const MatrixUnion &u)
    { MatrixUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MatrixUnion &operator=(MatrixUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MatrixUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MatrixTraits<typename RT::TableType>::enum_value;
    if (type != Matrix_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Matrix type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  MXRender::Data::Matrix_Column *AsMatrix_Column() {
    return type == Matrix_Matrix_Column ?
      reinterpret_cast<MXRender::Data::Matrix_Column *>(value) : nullptr;
  }
  const MXRender::Data::Matrix_Column *AsMatrix_Column() const {
    return type == Matrix_Matrix_Column ?
      reinterpret_cast<const MXRender::Data::Matrix_Column *>(value) : nullptr;
  }
  MXRender::Data::Matrix_Row *AsMatrix_Row() {
    return type == Matrix_Matrix_Row ?
      reinterpret_cast<MXRender::Data::Matrix_Row *>(value) : nullptr;
  }
  const MXRender::Data::Matrix_Row *AsMatrix_Row() const {
    return type == Matrix_Matrix_Row ?
      reinterpret_cast<const MXRender::Data::Matrix_Row *>(value) : nullptr;
  }
};


inline bool operator==(const MatrixUnion &lhs, const MatrixUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case Matrix_NONE: {
      return true;
    }
    case Matrix_Matrix_Column: {
      return *(reinterpret_cast<const MXRender::Data::Matrix_Column *>(lhs.value)) ==
             *(reinterpret_cast<const MXRender::Data::Matrix_Column *>(rhs.value));
    }
    case Matrix_Matrix_Row: {
      return *(reinterpret_cast<const MXRender::Data::Matrix_Row *>(lhs.value)) ==
             *(reinterpret_cast<const MXRender::Data::Matrix_Row *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const MatrixUnion &lhs, const MatrixUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyMatrix(flatbuffers::Verifier &verifier, const void *obj, Matrix type);
bool VerifyMatrixVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec3TypeTable();
  }
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

inline bool operator==(const Vec3 &lhs, const Vec3 &rhs) {
  return
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y()) &&
      (lhs.z() == rhs.z());
}

inline bool operator!=(const Vec3 &lhs, const Vec3 &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec4TypeTable();
  }
  Vec4() {
    memset(static_cast<void *>(this), 0, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

inline bool operator==(const Vec4 &lhs, const Vec4 &rhs) {
  return
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y()) &&
      (lhs.z() == rhs.z()) &&
      (lhs.w() == rhs.w());
}

inline bool operator!=(const Vec4 &lhs, const Vec4 &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix_Row FLATBUFFERS_FINAL_CLASS {
 private:
  MXRender::Data::Vec4 row0_;
  MXRender::Data::Vec4 row1_;
  MXRender::Data::Vec4 row2_;
  MXRender::Data::Vec4 row3_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Matrix_RowTypeTable();
  }
  Matrix_Row() {
    memset(static_cast<void *>(this), 0, sizeof(Matrix_Row));
  }
  Matrix_Row(const MXRender::Data::Vec4 &_row0, const MXRender::Data::Vec4 &_row1, const MXRender::Data::Vec4 &_row2, const MXRender::Data::Vec4 &_row3)
      : row0_(_row0),
        row1_(_row1),
        row2_(_row2),
        row3_(_row3) {
  }
  const MXRender::Data::Vec4 &row0() const {
    return row0_;
  }
  const MXRender::Data::Vec4 &row1() const {
    return row1_;
  }
  const MXRender::Data::Vec4 &row2() const {
    return row2_;
  }
  const MXRender::Data::Vec4 &row3() const {
    return row3_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix_Row, 64);

inline bool operator==(const Matrix_Row &lhs, const Matrix_Row &rhs) {
  return
      (lhs.row0() == rhs.row0()) &&
      (lhs.row1() == rhs.row1()) &&
      (lhs.row2() == rhs.row2()) &&
      (lhs.row3() == rhs.row3());
}

inline bool operator!=(const Matrix_Row &lhs, const Matrix_Row &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix_Column FLATBUFFERS_FINAL_CLASS {
 private:
  MXRender::Data::Vec4 column0_;
  MXRender::Data::Vec4 column1_;
  MXRender::Data::Vec4 column2_;
  MXRender::Data::Vec4 column3_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Matrix_ColumnTypeTable();
  }
  Matrix_Column() {
    memset(static_cast<void *>(this), 0, sizeof(Matrix_Column));
  }
  Matrix_Column(const MXRender::Data::Vec4 &_column0, const MXRender::Data::Vec4 &_column1, const MXRender::Data::Vec4 &_column2, const MXRender::Data::Vec4 &_column3)
      : column0_(_column0),
        column1_(_column1),
        column2_(_column2),
        column3_(_column3) {
  }
  const MXRender::Data::Vec4 &column0() const {
    return column0_;
  }
  const MXRender::Data::Vec4 &column1() const {
    return column1_;
  }
  const MXRender::Data::Vec4 &column2() const {
    return column2_;
  }
  const MXRender::Data::Vec4 &column3() const {
    return column3_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix_Column, 64);

inline bool operator==(const Matrix_Column &lhs, const Matrix_Column &rhs) {
  return
      (lhs.column0() == rhs.column0()) &&
      (lhs.column1() == rhs.column1()) &&
      (lhs.column2() == rhs.column2()) &&
      (lhs.column3() == rhs.column3());
}

inline bool operator!=(const Matrix_Column &lhs, const Matrix_Column &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Transform FLATBUFFERS_FINAL_CLASS {
 private:
  MXRender::Data::Vec3 position_;
  MXRender::Data::Vec3 rotation_;
  MXRender::Data::Vec3 scale_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransformTypeTable();
  }
  Transform() {
    memset(static_cast<void *>(this), 0, sizeof(Transform));
  }
  Transform(const MXRender::Data::Vec3 &_position, const MXRender::Data::Vec3 &_rotation, const MXRender::Data::Vec3 &_scale)
      : position_(_position),
        rotation_(_rotation),
        scale_(_scale) {
  }
  const MXRender::Data::Vec3 &position() const {
    return position_;
  }
  const MXRender::Data::Vec3 &rotation() const {
    return rotation_;
  }
  const MXRender::Data::Vec3 &scale() const {
    return scale_;
  }
};
FLATBUFFERS_STRUCT_END(Transform, 36);

inline bool operator==(const Transform &lhs, const Transform &rhs) {
  return
      (lhs.position() == rhs.position()) &&
      (lhs.rotation() == rhs.rotation()) &&
      (lhs.scale() == rhs.scale());
}

inline bool operator!=(const Transform &lhs, const Transform &rhs) {
    return !(lhs == rhs);
}


inline bool VerifyMatrix(flatbuffers::Verifier &verifier, const void *obj, Matrix type) {
  switch (type) {
    case Matrix_NONE: {
      return true;
    }
    case Matrix_Matrix_Column: {
      return verifier.Verify<MXRender::Data::Matrix_Column>(static_cast<const uint8_t *>(obj), 0);
    }
    case Matrix_Matrix_Row: {
      return verifier.Verify<MXRender::Data::Matrix_Row>(static_cast<const uint8_t *>(obj), 0);
    }
    default: return true;
  }
}

inline bool VerifyMatrixVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMatrix(
        verifier,  values->Get(i), types->GetEnum<Matrix>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MatrixUnion::UnPack(const void *obj, Matrix type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Matrix_Matrix_Column: {
      auto ptr = reinterpret_cast<const MXRender::Data::Matrix_Column *>(obj);
      return new MXRender::Data::Matrix_Column(*ptr);
    }
    case Matrix_Matrix_Row: {
      auto ptr = reinterpret_cast<const MXRender::Data::Matrix_Row *>(obj);
      return new MXRender::Data::Matrix_Row(*ptr);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MatrixUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Matrix_Matrix_Column: {
      auto ptr = reinterpret_cast<const MXRender::Data::Matrix_Column *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Matrix_Matrix_Row: {
      auto ptr = reinterpret_cast<const MXRender::Data::Matrix_Row *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    default: return 0;
  }
}

inline MatrixUnion::MatrixUnion(const MatrixUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Matrix_Matrix_Column: {
      FLATBUFFERS_ASSERT(false);  // MXRender::Data::Matrix_Column not copyable.
      break;
    }
    case Matrix_Matrix_Row: {
      FLATBUFFERS_ASSERT(false);  // MXRender::Data::Matrix_Row not copyable.
      break;
    }
    default:
      break;
  }
}

inline void MatrixUnion::Reset() {
  switch (type) {
    case Matrix_Matrix_Column: {
      auto ptr = reinterpret_cast<MXRender::Data::Matrix_Column *>(value);
      delete ptr;
      break;
    }
    case Matrix_Matrix_Row: {
      auto ptr = reinterpret_cast<MXRender::Data::Matrix_Row *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Matrix_NONE;
}

inline const flatbuffers::TypeTable *MatrixTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MXRender::Data::Matrix_ColumnTypeTable,
    MXRender::Data::Matrix_RowTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Matrix_Column",
    "Matrix_Row"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec3TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12 };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec4TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12, 16 };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Matrix_RowTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MXRender::Data::Vec4TypeTable
  };
  static const int64_t values[] = { 0, 16, 32, 48, 64 };
  static const char * const names[] = {
    "row0",
    "row1",
    "row2",
    "row3"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Matrix_ColumnTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MXRender::Data::Vec4TypeTable
  };
  static const int64_t values[] = { 0, 16, 32, 48, 64 };
  static const char * const names[] = {
    "column0",
    "column1",
    "column2",
    "column3"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransformTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MXRender::Data::Vec3TypeTable
  };
  static const int64_t values[] = { 0, 12, 24, 36 };
  static const char * const names[] = {
    "position",
    "rotation",
    "scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, type_refs, values, names
  };
  return &tt;
}

}  // namespace Data
}  // namespace MXRender

#endif  // FLATBUFFERS_GENERATED_COMMON_MXRENDER_DATA_H_
